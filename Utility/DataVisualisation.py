import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os

from math import ceil

def clean_data(curvature_data_path, subject_data_path, merged_data_path):
    """
    Cleans and merges data genearted by post processing scripts and general ADNI spreadsheet to create a mastersheet to be used for visualization and analysis

    Args:
        curvature_data_path (string): path to csv generated by post processing scripts. Should be input as a raw string to avoid escape character errors. Note the datasheet must be a csv
        subject_data_path (string): path to excel sheet of subject data. Should be input as a raw string to avoid escape character errors
        merged_data_path (string): path where to save the newly cleaned and merged data. Should be input as a raw string to avoid escape character errors. Must use a csv file
        
    Returns:
        none. New csv is generated
        
    Example:
        >>> clean_data(r'C:\path\of\curv\data.csv', r'C:\path\of\sub\data.xlsx', r'C:\path\of\generated\sheet.csv')
        A csv will be generated at C:\path\of\generated\sheet.csv consisting of data joined and cleaned from C:\path\of\curv\data.csv and C:\path\of\sub\data.xlsx
        
    """
    # Load data into pandas
    print('Loading data into pandas')
    curvature_data = pd.read_csv(curvature_data_path, converters={'SUBJECT_ID': str, 'dx': str}).sort_values(by=['SUBJECT_ID','MONTH_NUMBER'])
    subject_data=pd.read_excel(subject_data_path)

    # Make subject data have the same format as datasheets
    print('Changing SubjID column')
    for row, subject in enumerate(subject_data['SubjID']):
        new_sub_id = subject[-4:]
        subject_data.loc[row, ['SubjID']] = new_sub_id
    
    # Change dx to use abbreveations
    print('Changing dx column')
    subject_data['dx'] = subject_data['dx'].astype(str)
    for row, diag in enumerate(subject_data['dx']):
        match diag:
            case '1.0':
                new_diag = 'CN'
                
            case '2.0':
                new_diag = 'MCI'
            
            case '3.0':
                new_diag = 'AD'
            
            case _:
                new_diag = 'Diag missing or incorrrect'
                
        subject_data.loc[row, ['dx']] = new_diag
    
    subject_data = subject_data.sort_values(by=['SubjID', 'Visit'])
    
    # Rename Columns for Join
    print("Renaming columns to match")
    subject_data = subject_data.rename(columns={'SubjID' : 'SUBJECT_ID', 'Visit' : 'TIME_POINT'})
    
    # Join Tables
    print("Joining tables")
    joined_data = pd.merge(
        curvature_data, subject_data, how="left", on=['SUBJECT_ID', 'TIME_POINT']
    )
    
    # Write to new sheet
    print(f"Writing to new csv located at {merged_data_path}")
    joined_data.to_csv(merged_data_path, index=False)
    
    print("Data cleaning done press enter to continue\n")

    
def generate_group_graph(data, group, group_id, metric, output):
    """
    Generates a single graph for a group of subjects on a given metric

    Args:
        data (string): path to the data being used to generate graph. Should be input as a raw string to avoid escape character errors. Note the datasheet must be a csv
        group (list of str): list of subject id strings that will be graphed.
        group_id (string): name describing group, will be used for the file name and title of graph
        metric (string): name of the column that you wish to be graphed. Will always graph against month number on the y-axis
        output (string): path to the desired output location. Image name is generated as {group_id}_{metric}.png. Note spaces will be replaced with underscores in file name.
        
    Returns:
        none. png of graph is generated in the specified location
        
    Example:
        >>> generate_group_graph(r'C:\path\of\datasheet.csv', ['0001','0002,'0003','0004'], 'group 1', 'R_CORTICAL_SA', r'C:\path\of\output')
        File will be generated at C:\path\of\output\group_1_R_CORTICAL_SA.png}
    """
    if len(group) == 0:
        raise ValueError("Group can not be empty")
    # common variables
    
    print("Reading data from csv")
    data = pd.read_csv(data, converters={'SUBJECT_ID': str})
    grouped_data = data.groupby('SUBJECT_ID')
    num_subgroups = ceil(len(group)/10)
    
    # Create each subgroup and plot
    for i in range(num_subgroups):
        subgroup = group[i * 10: (i + 1) * 10]
        subgroup_id = f"{group_id}_part_{i + 1}"
        
        # Graph settings
        plt.figure(figsize=(20, 14))
        plt.xlabel('Month of Scan')
        plt.ylabel(metric)
        plt.title(f'{subgroup_id} {metric}')
        plt.grid()

        # Iterate over each subject in subgroup and plot
        print("Begin Graphing")
        for subject in subgroup:
            print(f"Adding subject {subject} to graph")
            subject_data = grouped_data.get_group(subject)
            months = subject_data['MONTH_NUMBER'].to_numpy()
            metric_data = subject_data[metric].to_numpy()
            diagnosis_data = subject_data['dx'].to_numpy()

            # Plot data
            plt.plot(months, metric_data, label=f'Subject {subject}')

            # Annotate scatter points based on diagnosis
            print(f"Annotating subject {subject} graph")
            for j, diag in enumerate(diagnosis_data):
                color = 'green' if diag == 'CN' else 'yellow' if diag == 'MCI' else 'red' if diag == 'AD' else 'purple'
                plt.scatter(months[j], metric_data[j], color=color)

        # Adjust ticks
        plt.xticks(np.arange(0, 210, step=6))
        metric_min = data[metric].min()
        metric_max = data[metric].max()

        # Generate 25 ticks between min and max
        y_ticks = np.linspace(metric_min, metric_max, 25)

        # Calculate the interval between ticks
        tick_interval = y_ticks[1] - y_ticks[0]

        # Extend ticks by adding one below the min and one above the max
        y_ticks = np.append(y_ticks, y_ticks[-1] + tick_interval)
        y_ticks = np.insert(y_ticks, 0, y_ticks[0] - tick_interval)

        # Set the yticks with the extended range
        plt.yticks(y_ticks)

        # Add legend after plotting all subjects in the subgroup
        plt.legend(loc='lower right')

        # Save the graph
        output_path = os.path.join(output, f"{subgroup_id}_{metric}.png")
        print(f"Saving image at {output_path}")
        os.makedirs(output, exist_ok=True)
        plt.savefig(output_path)
        
        plt.close()
        print("Complete\n")


def generate_single_graph(data, subject, metric, output):
    """
    Generates a graph for a single subject on a given metric

    Args:
        data (string): path to the data being used to generate graph. Should be input as a raw string to avoid escape character errors. Note the datasheet must be a csv
        subject (string): string of the subject_id as it appears in the data sheet
        metric (string): name of the column that you wish to be graphed. Will always graph against month number on the y-axis
        output (string): path to the desired output location. Image name is generated as {subject}_{metric}.png
        
    Returns:
        none. png of graph is generated in the specified location
        
    Example:
        >>> generate_single_graph(r'C:\path\of\datasheet.csv', '0001', 'R_CORTICAL_SA', r'C:\path\of\output')
        File will be generated at C:\path\of\output\0001_R_CORTICAL_SA.png}
    """
    
    # gather data
    print(fr"Reading data for subject {subject} with metric {metric} from data located at {data}")
    data = pd.read_csv(data, converters={'SUBJECT_ID': str})
    grouped_data = data.groupby('SUBJECT_ID')
    subject_data = grouped_data.get_group(subject)
    months = subject_data['MONTH_NUMBER'].to_numpy()
    metric_data = subject_data[metric].to_numpy()
    diagnosis_data = subject_data['dx'].to_numpy()
    a,b = np.polyfit(months, metric_data, 1)
    
    # graph settings
    print("Generating graph")
    plt.figure(figsize=(20,14))
    plt.title(f'Subject {subject} {metric}')
    plt.ylabel(metric)
    plt.xlabel('MONTH_NUMBER')
    plt.grid()
    
    # graph data
    plt.scatter(months, metric_data)
    plt.plot(months, metric_data)
    plt.plot(months, a*months+b, linestyle='--')
    
    # annotate data
    for i, diag in enumerate(diagnosis_data):
        if diag == 'CN':
            plt.scatter(months[i], metric_data[i], color='green')
        elif diag == 'MCI':
            plt.scatter(months[i], metric_data[i], color='yellow')
        elif diag == 'AD':
            plt.scatter(months[i], metric_data[i], color='red')
        else:
            plt.scatter(months[i], metric_data[i], color='purple')
        plt.annotate(diag, (months[i], metric_data[i]), textcoords="offset points", xytext=(0,10), ha='center')
        
    # set graph ticks
    plt.grid()
    metric_min = data[metric].min()
    metric_max = data[metric].max()

    # Generate 25 ticks between min and max
    y_ticks = np.linspace(metric_min, metric_max, 25)

    # Calculate the interval between ticks
    tick_interval = y_ticks[1] - y_ticks[0]

    # Extend ticks by adding one below the min and one above the max
    y_ticks = np.append(y_ticks, y_ticks[-1] + tick_interval)
    y_ticks = np.insert(y_ticks, 0, y_ticks[0] - tick_interval)

    # Set the yticks with the extended range
    plt.yticks(y_ticks)
    plt.xticks(np.arange(0, 210, step=6))
    
    # save and close graph
    print(fr"Saving image at {output}\{subject}_{metric}.png")
    try:
        plt.savefig(fr'{output}\{subject}_{metric}.png')
    except FileNotFoundError:
        os.makedirs(output)
        plt.savefig(fr'{output}\{subject}_{metric}.png')
        
    plt.close()
    print("Complete\n")
    

def graph_all_subjects(data, metrics, output):
    """
    Generates graphs for every subject for each provided metric in provided data sheet. Note that groups large than 10 will produce multiple graphs

    Args:
        data (string): path to the data being used to generate graph. Should be input as a raw string to avoid escape character errors. Note the datasheet must be a csv
        metric (list of str): list of metrics to run
        output (string): path to the desired output location. Will generate a folder for each subject
        
    Returns:
        none. Folder of png files will be created for each subject
        
    Example:
        >>> generate_all_subjects(r'C:\path\of\datasheet.csv', ['R_CORTICAL_SA', 'L_CORTICAL_SA'], r'C:\path\of\output')
        Will generate a file for each subject with the contents being two pngs corosponding to the R_CORTICAL_SA and L_CORTICAL_SA
    """
    # get list of subjects and determine subgroups if any
    print(f"Reading data from {data}")
    grouped_data = pd.read_csv(data, converters={'SUBJECT_ID': str}).groupby('SUBJECT_ID')
    subjects = grouped_data.groups.keys()
    
    
    # pass to generate single function
    print("Generating graphs")
    for subject in subjects:
        for metric in metrics:
            generate_single_graph(data, subject, metric, f'{output}\{subject}')
    
 
def get_group(data, group_by, comparison, value):
    """
    Creates a list of subject ids that meet a specific criteria

    Args:
        data (string): path to the data being used to generate graph. Should be input as a raw string to avoid escape character errors. Note the datasheet must be a csv
        group_by (string): string of the column that should be used for comparison.
        comparison (string): how the value in the data should be compared to the test vaule must be 'EQUAL', 'LT' (less than), 'GT', 'LTE'(less than or equal too), or 'GTE'. Not comparison will alwyas use the BL or MONTH_NUMBER 0 row
        value (string, int or float): string int or flaot to be compared to. Note strings must use 'EQUAL' for comparison
        
    Returns:
        list of strings
        
    Examples:
        >>> get_group(r'C:\path\of\datasheet.csv', 'female_gender', 'EQUAL', 1)
        returns list of all subjects who are female base on their data at BL
        >>> get_group(r'C:\path\of\datasheet.csv', 'age', 'LTE', 72)
        returns list of all subejcts who were younger than 72 at BL
        >>> get_group(r'C:\path\of\datasheet.csv', 'dx', 'EQUAL', MCI)
        returns list of all subjets who had a diagnosis of MCI at BL
    """  
    # validate options
    valid_comparison = {'EQUAL', 'LT', 'GT', 'LTE', 'GTE'}
    if comparison not in valid_comparison:
        raise ValueError(f"results: comparison must be one of {valid_comparison}.")
    if type(value) == str and comparison != 'EQUAL':
        raise ValueError("results: comparison to strings must use 'EQUAL' for comparison.")
    
    
    # Data setup
    data = pd.read_csv(data, converters={'SUBJECT_ID': str})
    grouped_data = data.groupby('SUBJECT_ID')
    subject_list = []
    
    # compare data
    for subject in grouped_data.groups.keys():
        subject_data = grouped_data.get_group(subject)
        subject_bl = subject_data.loc[subject_data['MONTH_NUMBER'] == 0]
        
        match comparison:
            case 'EQUAL':
                if subject_bl[group_by].iloc[0] == value:
                    print(f"Subject {subject} matches the criteria")
                    subject_list.append(subject)
                    continue
            case 'LT':
                if subject_bl[group_by].iloc[0] < value:
                    print(f"Subject {subject} matches the criteria")
                    subject_list.append(subject)
                    continue
            case 'GT':
                if subject_bl[group_by].iloc[0] > value:
                    print(f"Subject {subject} matches the criteria")
                    subject_list.append(subject)
                    continue
            case 'LTE':
                if subject_bl[group_by].iloc[0] <= value:
                    print(f"Subject {subject} matches the criteria")
                    subject_list.append(subject)
                    continue
            case 'GTE':
                if subject_bl[group_by].iloc[0] >= value:
                    print(f"Subject {subject} matches the criteria")
                    subject_list.append(subject)
                    continue
    
    # return list
    return subject_list

